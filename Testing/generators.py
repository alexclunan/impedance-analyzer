"""
Signal, noise, and error generators for impedance analyzer testbench.

Provides sine/cosine waves, multiple noise types (time and frequency domain),
and error models for DAC, op-amp, and ADC simulation.
"""

from __future__ import annotations

import numpy as np
from typing import Literal, Optional
from enum import Enum


# -----------------------------------------------------------------------------
# 1. Sine / Cosine wave generators
# -----------------------------------------------------------------------------

def sine_wave(
    t: np.ndarray,
    frequency: float,
    amplitude: float = 1.0,
    phase: float = 0.0,
    dc_offset: float = 0.0,
) -> np.ndarray:
    """
    Generate a sine wave in the time domain.

    Args:
        t: Time samples (seconds).
        frequency: Frequency in Hz.
        amplitude: Peak amplitude.
        phase: Phase in radians.
        dc_offset: DC offset.

    Returns:
        Array of shape (t.size,) with sine values.
    """
    return dc_offset + amplitude * np.sin(2.0 * np.pi * frequency * t + phase)


def cosine_wave(
    t: np.ndarray,
    frequency: float,
    amplitude: float = 1.0,
    phase: float = 0.0,
    dc_offset: float = 0.0,
) -> np.ndarray:
    """
    Generate a cosine wave in the time domain.

    Args:
        t: Time samples (seconds).
        frequency: Frequency in Hz.
        amplitude: Peak amplitude.
        phase: Phase in radians.
        dc_offset: DC offset.

    Returns:
        Array of shape (t.size,) with cosine values.
    """
    return dc_offset + amplitude * np.cos(2.0 * np.pi * frequency * t + phase)


def multifrequency_sine(
    t: np.ndarray,
    frequencies: np.ndarray,
    amplitudes: np.ndarray,
    phases: Optional[np.ndarray] = None,
    dc_offset: float = 0.0,
) -> np.ndarray:
    """
    Sum of sinusoids (multifrequency excitation as in README).

    Args:
        t: Time samples (seconds).
        frequencies: Array of frequencies (Hz).
        amplitudes: Array of amplitudes (same length as frequencies).
        phases: Optional phases in radians; default zero.
        dc_offset: DC offset.

    Returns:
        Composite waveform, shape (t.size,).
    """
    n = len(frequencies)
    if len(amplitudes) != n:
        raise ValueError("amplitudes must match length of frequencies")
    if phases is None:
        phases = np.zeros(n)
    elif len(phases) != n:
        raise ValueError("phases must match length of frequencies")

    out = np.zeros_like(t, dtype=float)
    for k in range(n):
        out += amplitudes[k] * np.sin(2.0 * np.pi * frequencies[k] * t + phases[k])
    return out + dc_offset


# -----------------------------------------------------------------------------
# 2. Noise generators (time and frequency domain)
# -----------------------------------------------------------------------------

class NoiseType(str, Enum):
    """Supported noise types."""
    WHITE = "white"
    PINK = "pink"           # 1/f
    BROWNIAN = "brownian"   # 1/f^2 (Brownian)
    BLUE = "blue"           # f (high-freq emphasis)
    VIOLET = "violet"       # f^2
    BANDLIMITED_WHITE = "bandlimited_white"


def _pink_filter_approximate(n: int) -> np.ndarray:
    """Approximate 1/f filter in frequency domain (Voss-McCartney style)."""
    # Build magnitude that falls as 1/sqrt(f) so power ~ 1/f
    freqs = np.fft.rfftfreq(n)
    freqs[0] = freqs[1]  # avoid div by zero
    mag = 1.0 / np.sqrt(np.abs(freqs))
    mag[0] = 0.0
    return mag


def _brownian_filter(n: int) -> np.ndarray:
    """1/f^2 (Brownian) filter in frequency domain."""
    freqs = np.fft.rfftfreq(n)
    freqs[0] = freqs[1]
    mag = 1.0 / np.abs(freqs)
    mag[0] = 0.0
    return mag


def _blue_filter(n: int) -> np.ndarray:
    """f (blue) filter in frequency domain."""
    freqs = np.fft.rfftfreq(n)
    return np.abs(freqs)


def _violet_filter(n: int) -> np.ndarray:
    """f^2 (violet) filter in frequency domain."""
    freqs = np.fft.rfftfreq(n)
    return freqs ** 2


def noise_time_domain(
    n_samples: int,
    noise_type: NoiseType | str = NoiseType.WHITE,
    scale: float = 1.0,
    rng: Optional[np.random.Generator] = None,
) -> np.ndarray:
    """
    Generate noise in the time domain.

    White noise is generated directly; colored noise is generated by
    shaping white noise in the frequency domain and then IFFT.

    Args:
        n_samples: Number of samples.
        noise_type: One of white, pink, brownian, blue, violet, bandlimited_white.
        scale: RMS scale factor for output.
        rng: Optional NumPy random generator for reproducibility.

    Returns:
        Real-valued noise array of shape (n_samples,).
    """
    if rng is None:
        rng = np.random.default_rng()
    if isinstance(noise_type, str):
        noise_type = NoiseType(noise_type)

    if noise_type == NoiseType.WHITE:
        x = rng.standard_normal(n_samples)
        if scale != 1.0:
            x = x * scale
        return x

    if noise_type == NoiseType.BANDLIMITED_WHITE:
        # Bandlimited: white only up to some fraction of Nyquist
        frac = 0.25  # default: 0 to fs/8
        n_fft = n_samples
        freqs = np.fft.rfftfreq(n_fft)
        cutoff = frac * 0.5
        mask = np.abs(freqs) <= cutoff
        phase = rng.uniform(0, 2 * np.pi, freqs.shape)
        spec = np.where(mask, np.exp(1j * phase), 0.0)
        x = np.fft.irfft(spec, n=n_fft)
        if x.size > n_samples:
            x = x[:n_samples]
        elif x.size < n_samples:
            x = np.pad(x, (0, n_samples - x.size))
        rms = np.sqrt(np.mean(x ** 2))
        if rms > 0:
            x = x * (scale / rms)
        return x

    # Colored: generate white in freq domain, apply filter, IFFT
    n_fft = n_samples
    phase = rng.uniform(0, 2 * np.pi, n_fft // 2 + 1)
    phase[0] = 0.0
    if n_fft % 2 == 0:
        phase[-1] = 0.0

    if noise_type == NoiseType.PINK:
        mag = _pink_filter_approximate(n_fft)
    elif noise_type == NoiseType.BROWNIAN:
        mag = _brownian_filter(n_fft)
    elif noise_type == NoiseType.BLUE:
        mag = _blue_filter(n_fft)
    elif noise_type == NoiseType.VIOLET:
        mag = _violet_filter(n_fft)
    else:
        mag = np.ones(n_fft // 2 + 1)

    spec = mag * np.exp(1j * phase)
    x = np.fft.irfft(spec, n=n_fft)
    if x.size > n_samples:
        x = x[:n_samples]
    elif x.size < n_samples:
        x = np.pad(x, (0, n_samples - x.size))

    rms = np.sqrt(np.mean(x ** 2))
    if rms > 0:
        x = x * (scale / rms)
    return x


def noise_frequency_domain(
    n_bins: int,
    noise_type: NoiseType | str = NoiseType.WHITE,
    scale: float = 1.0,
    rng: Optional[np.random.Generator] = None,
) -> np.ndarray:
    """
    Generate noise directly in the frequency domain (complex spectrum).

    Returns complex array of shape (n_bins,) with Hermitian symmetry
    implied for real-valued time signal (only first n_bins used as positive
    frequencies; use with irfft for full spectrum).

    Args:
        n_bins: Number of positive frequency bins (rfft size).
        noise_type: White, pink, brownian, etc. (shapes magnitude).
        scale: Scale for magnitude.
        rng: Optional random generator.

    Returns:
        Complex array of shape (n_bins,).
    """
    if rng is None:
        rng = np.random.default_rng()
    if isinstance(noise_type, str):
        noise_type = NoiseType(noise_type)

    phase = rng.uniform(0, 2 * np.pi, n_bins)
    # For real signal: DC and Nyquist real
    phase[0] = 0.0

    freqs = np.arange(n_bins, dtype=float)
    freqs[0] = 1.0
    if noise_type == NoiseType.WHITE:
        mag = np.ones(n_bins)
    elif noise_type == NoiseType.PINK:
        mag = 1.0 / np.sqrt(freqs)
    elif noise_type == NoiseType.BROWNIAN:
        mag = 1.0 / freqs
    elif noise_type == NoiseType.BLUE:
        mag = freqs
    elif noise_type == NoiseType.VIOLET:
        mag = freqs ** 2
    else:
        mag = np.ones(n_bins)

    mag[0] = 0.0
    return scale * mag * np.exp(1j * phase)


# -----------------------------------------------------------------------------
# 3. Error generators (phase delay, DAC, op-amp, ADC)
# -----------------------------------------------------------------------------

def apply_phase_delay(
    signal: np.ndarray,
    phase_delay_rad: float,
    sample_rate_hz: float,
    frequency_hz: float,
) -> np.ndarray:
    """
    Apply a constant phase delay at a given frequency (linear phase = delay).

    delay_time = phase_delay_rad / (2*pi*f). Implemented by circular shift
    of samples approximating that delay.
    """
    if np.abs(frequency_hz) < 1e-12:
        return signal.copy()
    delay_sec = phase_delay_rad / (2.0 * np.pi * frequency_hz)
    delay_samples = delay_sec * sample_rate_hz
    n = len(signal)
    shift = int(np.round(delay_samples)) % n
    if shift == 0:
        return signal.copy()
    return np.roll(signal, -shift)


def dac_errors(
    digital_codes: np.ndarray,
    n_bits: int = 16,
    inl_lsb: float = 4.0,
    dnl_lsb: float = 0.5,
    gain_error: float = 0.0,
    offset_error: float = 0.0,
    glitch_energy_frac: float = 0.0,
    rng: Optional[np.random.Generator] = None,
) -> np.ndarray:
    """
    Simulate common DAC errors: INL, DNL, gain, offset, and optional glitch.

    Models typical high-speed 16-bit DAC (e.g. 250+ MSPS class).
    digital_codes: integer codes in [0, 2^n_bits - 1], or float in [0,1] normalized.
    """
    if rng is None:
        rng = np.random.default_rng()

    codes = np.asarray(digital_codes, dtype=float)
    max_code = (1 << n_bits) - 1
    if codes.max() <= 1.0 and codes.min() >= 0.0:
        codes = codes * max_code
    codes = np.clip(codes, 0, max_code)

    # Ideal output normalized to [0, 1]
    ideal = codes / max_code

    # INL: integral nonlinearity (cumulative deviation from ideal)
    # Simplified: random walk per code, scaled by inl_lsb
    n_levels = 1 << n_bits
    inl_profile = np.cumsum(rng.standard_normal(n_levels))
    inl_profile = inl_profile - inl_profile.mean()
    inl_profile = inl_profile / (np.abs(inl_profile).max() + 1e-12) * (inl_lsb / max_code)
    code_int = np.clip(codes.astype(int), 0, n_levels - 1)
    inl_error = inl_profile[code_int]

    # DNL: differential nonlinearity (per-step error)
    dnl_random = rng.standard_normal(codes.shape) * (dnl_lsb / max_code)
    dac_out = ideal + inl_error + dnl_random

    # Gain and offset (applied to normalized output)
    dac_out = dac_out * (1.0 + gain_error) + offset_error

    # Optional glitch: add small random spikes on large code transitions
    if glitch_energy_frac > 0:
        diff = np.diff(dac_out, prepend=dac_out[0])
        transition = np.abs(diff) > np.percentile(np.abs(diff), 99)
        glitch = rng.standard_normal(dac_out.shape) * glitch_energy_frac
        dac_out = dac_out + glitch * transition

    return dac_out


def _iir_first_order_lpf(x: np.ndarray, alpha: float) -> np.ndarray:
    """First-order IIR LPF: y[n] = alpha*x[n] + (1-alpha)*y[n-1]."""
    y = np.empty_like(x)
    y[0] = alpha * x[0]
    for i in range(1, len(x)):
        y[i] = alpha * x[i] + (1.0 - alpha) * y[i - 1]
    return y


def opamp_errors(
    signal: np.ndarray,
    sample_rate_hz: float,
    gain_error: float = 0.0,
    offset_voltage: float = 0.0,
    bandwidth_hz: float = np.inf,
    noise_rms: float = 0.0,
    rng: Optional[np.random.Generator] = None,
) -> np.ndarray:
    """
    Simulate op-amp / TIA errors: gain error, offset, bandwidth limit, noise.

    First-order single-pole rolloff for bandwidth.
    """
    out = signal * (1.0 + gain_error) + offset_voltage

    if bandwidth_hz < np.inf and bandwidth_hz > 0:
        # Single-pole LPF in discrete time: alpha = 1 - exp(-2*pi*fb/fs)
        fc_norm = bandwidth_hz / sample_rate_hz
        if fc_norm < 0.5:
            alpha = 1.0 - np.exp(-2.0 * np.pi * fc_norm)
            out = _iir_first_order_lpf(out, alpha)

    if noise_rms > 0:
        if rng is None:
            rng = np.random.default_rng()
        out = out + rng.standard_normal(out.shape) * noise_rms

    return out


def adc_errors(
    analog_signal: np.ndarray,
    n_bits: int = 16,
    v_ref: float = 1.0,
    gain_error: float = 0.0,
    offset_error: float = 0.0,
    inl_lsb: float = 2.0,
    dnl_lsb: float = 0.5,
    aperture_jitter_sec: float = 0.0,
    sample_rate_hz: Optional[float] = None,
    rng: Optional[np.random.Generator] = None,
) -> np.ndarray:
    """
    Simulate ADC errors: quantization, INL, DNL, gain, offset, aperture jitter.

    High-speed 16-bit 100+ MSPS class. Output is integer codes in [0, 2^n_bits - 1].
    """
    if rng is None:
        rng = np.random.default_rng()

    x = np.asarray(analog_signal, dtype=float)
    n_levels = 1 << n_bits
    max_code = n_levels - 1

    # Aperture jitter: slight time uncertainty -> voltage error for fast signals
    if aperture_jitter_sec > 0 and sample_rate_hz is not None and len(x) > 1:
        dt = 1.0 / sample_rate_hz
        jitter = rng.standard_normal(x.shape) * aperture_jitter_sec
        # dV/dt approximated by central difference
        dx = np.gradient(x, dt)
        x = x + dx * jitter

    # Normalize to [0, 1] by Vref, then gain/offset
    x = x / v_ref * (1.0 + gain_error) + offset_error / v_ref

    # INL profile (per-code error)
    inl_profile = np.cumsum(rng.standard_normal(n_levels))
    inl_profile = inl_profile - inl_profile.mean()
    inl_profile = inl_profile / (np.abs(inl_profile).max() + 1e-12) * (inl_lsb / n_levels)

    # Map voltage to code (0 .. max_code)
    code_float = x * max_code
    code_int = np.clip(code_float.astype(int), 0, max_code)
    # Add INL at that code
    code_float = code_float + inl_profile[np.minimum(code_int, n_levels - 1)]
    # DNL
    code_float = code_float + rng.standard_normal(code_float.shape) * (dnl_lsb)

    # Quantize
    codes = np.clip(np.round(code_float), 0, max_code).astype(np.int32)
    return codes
